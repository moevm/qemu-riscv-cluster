# Инструкция по развертыванию системы

## Архитектура системы

Система состоит из следующих компонентов:
1. Несколько виртуальных машин RISC-V, созданных с помощью QEMU
2. Контроллер - центральный компонент управления (Go)
   - Управляет worker'ами через Unix-сокеты
   - Обеспечивает распределение задач
3. Worker'ы - компоненты обработки (C++)
   - Подключаются к контроллеру через Unix-сокеты
   - Выполняют вычисление хешей
4. Система мониторинга (Grafana, Prometheus, Loki)

## Порядок развертывания

### 1. Подготовка окружения

На хост-машине должны быть установлены:
- Linux с поддержкой KVM
- QEMU для эмуляции RISC-V

### 2. Подготовка компонентов

1. Подготовка базовых образов:
   - Создание образа для контроллера через Yocto:
     * Оптимизированный образ для RISC-V
     * Включает необходимые зависимости для Go
     * Настроен для работы с метриками и логами
   - Создание образа для worker'а через Yocto:
     * Оптимизированный образ для RISC-V
     * Включает необходимые C++ runtime зависимости
     * Настроен для работы с метриками и логами

2. Компиляция и развертывание контроллера:
   
   - Процесс:
     * Компиляция Go кода через Bazel в контейнере
     * Использование подготовленного Yocto-образа для запуска
     * Настройка volume для Unix-сокета
     * Экспорт метрик для Prometheus
     * Отправка логов в Loki

3. Компиляция и развертывание worker'ов:
   
   - Процесс:
     * Компиляция C++ кода через Bazel в контейнере
     * Использование подготовленного Yocto-образа для запуска
     * Подключение к Unix-сокету контроллера
     * Экспорт метрик для Prometheus
     * Отправка логов в Loki

4. Важные моменты:
   - Компиляция происходит в отдельных контейнерах с Bazel
   - Запуск осуществляется на образах, собранных через Yocto
   - Каждый компонент имеет свой docker-compose.yml
   - Настроен сбор метрик и логов для мониторинга

### 3. Мониторинг

1. Prometheus:
   - Сбор метрик с контроллера и worker'ов
   - Настройка целей через service discovery
   - Хранение исторических данных

2. Loki:
   - Централизованный сбор логов
   - Агрегация логов со всех компонентов
   - Структурированное хранение

3. Grafana:
   - Визуализация метрик из Prometheus
   - Просмотр логов из Loki
   - Настроенные дашборды для мониторинга

## Важные замечания

1. Порядок запуска важен: сначала контроллер, затем worker'ы
2. Все компоненты запускаются через Docker Compose
3. Коммуникация через Unix-сокеты
4. SSH используется только для управления VM
5. Базовые образы создаются через Yocto
6. Компиляция происходит через Bazel в контейнере
7. При обновлении кода:
   - Остановка соответствующего сервиса
   - Пересборка через docker-compose up --build
   - Логи и метрики сохраняются в системе мониторинга

### 7. Проверка работоспособности

1. В Grafana проверяется:
   - Статус контроллера
   - Статус каждого worker'а
   - Метрики производительности
   - Системные ресурсы

2. В логах контроллера проверяется:
   - Создание Unix-сокета
   - Подключение worker'ов
   - Отсутствие ошибок взаимодействия

### 8. Управление системой

Основные операции управления:
1. Остановка/запуск отдельных worker'ов
2. Перезапуск контроллера при необходимости
3. Полная остановка системы в следующем порядке:
   - Остановка всех worker'ов
   - Остановка контроллера
   - Остановка виртуальных машин
   - Остановка системы мониторинга

### 9. Устранение неполадок

При возникновении проблем проверяется:
1. Доступность SSH для управления VM
2. Наличие и права доступа к Unix-сокету
3. Логи контроллера на предмет ошибок IPC
4. Логи worker'ов для проверки подключения
5. Метрики в Prometheus
6. Состояние Docker контейнеров

## Важные замечания

1. Порядок запуска важен: сначала контроллер, затем worker'ы
2. Все компоненты работают в Docker контейнерах
3. Коммуникация между контроллером и worker'ами через Unix-сокеты
4. SSH используется только для управления VM
5. Мониторинг осуществляется централизованно через Grafana
6. Сборка кода происходит через Bazel в контейнере
7. При обновлении кода:
   - Пересборка через Bazel в контейнере
   - Перезапуск обновленных компонентов 