# Инструкция по развертыванию системы

## Архитектура системы

Система состоит из следующих компонентов:
1. Несколько виртуальных машин с Linux
2. Контроллер - центральный компонент управления (Go)
   - Управляет worker'ами через Unix-сокеты
   - Обеспечивает распределение задач
3. Worker'ы - компоненты обработки (C++)
   - Подключаются к контроллеру через Unix-сокеты
   - Выполняют вычисление хешей
4. Система мониторинга (Grafana, Prometheus, Loki)

## Порядок развертывания

### 1. Подготовка окружения

На хост-машине должны быть установлены:
- Linux с поддержкой KVM
- Docker и Docker Compose
- Git для работы с репозиторием

### 2. Подготовка компонентов

1. Подготовка контроллера:
   - Сборка и создание Docker-образа:
     ```bash
     cd controller
     docker build -f Dockerfile.controller -t controller:latest .
     ```
   - Особенности сборки:
     * Использует базовый образ с Bazel
     * Сборка Go кода происходит внутри контейнера через Bazel
     * Создается volume для Unix-сокета

2. Подготовка worker'ов:
   - Сборка и создание Docker-образа:
     ```bash
     cd controller
     docker build -f Dockerfile.worker -t worker:latest .
     ```
   - Особенности сборки:
     * Использует базовый образ с Bazel
     * Сборка C++ кода происходит внутри контейнера
     * Настройка окружения для worker'а

3. Важные моменты при сборке:
   - Bazel используется для сборки как Go, так и C++ кода
   - Сборка происходит внутри Docker-контейнера
   - Все зависимости описаны в WORKSPACE и BUILD файлах
   - Docker-образы содержат только необходимые для работы файлы

4. Проверка корректности:
   - Запуск тестов через Bazel
   - Проверка собранных Docker-образов
   - Тестирование на целевой системе

### 3. Запуск виртуальных машин

1. В файле ports.conf указываются порты для каждой VM (по одному порту на строку)
2. Скрипт run.sh читает этот файл и запускает соответствующее количество VM
3. Для каждой VM настраивается проброс портов SSH
4. Первая VM (первый порт в списке) будет использоваться для контроллера
5. Остальные VM будут использоваться для worker'ов

### 4. Запуск системы мониторинга

На хост-машине запускается стек мониторинга(с помощью docker-compose):
1. Grafana - для визуализации
2. Prometheus - для сбора метрик
3. Loki - для сбора логов

### 5. Развертывание контроллера

1. На первой VM запускается контроллер через docker-compose
2. В docker-compose.controller.yml указываются:
   - Путь к Unix-сокету для коммуникации с worker'ами
   - Порт для метрик Prometheus
   - Настройки для отправки логов в Loki
3. Unix-сокет монтируется в контейнер через volume

### 6. Развертывание worker'ов

1. На каждой VM запускается worker через docker-compose
2. Для каждого worker'а создается конфигурация:
   - В docker-compose.yml монтируется тот же путь к Unix-сокету
   - Настраивается привязка к CPU через Docker
   - Указываются параметры для отправки метрик и логов

### 7. Проверка работоспособности

1. В Grafana проверяется:
   - Статус контроллера
   - Статус каждого worker'а
   - Метрики производительности
   - Системные ресурсы

2. В логах контроллера проверяется:
   - Создание Unix-сокета
   - Подключение worker'ов
   - Отсутствие ошибок взаимодействия

### 8. Управление системой

Основные операции управления:
1. Остановка/запуск отдельных worker'ов
2. Перезапуск контроллера при необходимости
3. Полная остановка системы в следующем порядке:
   - Остановка всех worker'ов
   - Остановка контроллера
   - Остановка виртуальных машин
   - Остановка системы мониторинга

### 9. Устранение неполадок

При возникновении проблем проверяется:
1. Доступность SSH для управления VM
2. Наличие и права доступа к Unix-сокету
3. Логи контроллера на предмет ошибок IPC
4. Логи worker'ов для проверки подключения
5. Метрики в Prometheus
6. Состояние Docker контейнеров

## Важные замечания

1. Порядок запуска важен: сначала контроллер, затем worker'ы
2. Все компоненты работают в Docker контейнерах
3. Коммуникация между контроллером и worker'ами через Unix-сокеты
4. SSH используется только для управления VM
5. Мониторинг осуществляется централизованно через Grafana
6. Сборка всех компонентов происходит через Bazel внутри Docker
7. При обновлении кода:
   - Пересборка соответствующего Docker-образа
   - Обновление контейнеров в системе 